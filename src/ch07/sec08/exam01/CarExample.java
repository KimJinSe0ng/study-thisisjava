package ch07.sec08.exam01;

/**
 * <다형성>
 *     사용 방법은 동일하지만 실행 결과가 다양하게 나오는 성질
 *     예를 들어, 자동차의 부품을 교환하면 성능이 다르게 나오듯이 객체는 부품과 같아서, 프로그램을 구성하는 객체를 바꾸면 프로그램의 실행 성능이 다르게 나올 수 있다.
 *     객체 사용 방법이 동일하다 = 동일한 메소드를 가지고 있다.
 *     다형성을 구현하기 위해서는 자동 타입 변환과 메소드 재정의가 필요하다.
 *     ex) 한국 타이어와 금호 타이어는 모두 타이어를 상속한다. -> 한국 타이어와 금호 타이어는 타이어(부모)의 메소드를 동일하게 갖고 있다.
 *         만약 한국 타이어와 금호 타이어가 타이어(부모)의 메소드를 오버라이딩 하고 있다면, 타이어 메소드 호출 시 오버라이딩된 메소드가 호출된다.
 *         오버라이딩 된 내용은 두 타이어가 다르기 때문에 실행 결과가 다르게 나온다. -> 다형성
 *     <필드 다형성>
 *         필드 타입은 동일하지만(사용 방법은 동일하지만), 대입되는 객체가 달라져서 실행 결과가 다양하게 나올 수 있는 것을 말한다.
 */
public class CarExample {
    public static void main(String[] args) {
        // Car 객체 생성
        Car myCar = new Car();

        // Tire 객체 생성
        myCar.tire = new Tire();
        myCar.run();

        // HankookTire 객체 장착
        myCar.tire = new HankookTire(); // 한국 타이어 객체를 Tire 필드에 대입할 수 있다. (자동 타입 변환)
        myCar.run(); // 대입된(장착된) 타이어의 roll() 메소드 호출

        // KumhoTire 객체 장착
        myCar.tire = new KumhoTire(); // 금호 타이어 객체를 Tire 필드에 대입할 수 있다. (자동 타입 변환)
        myCar.run(); // 대입된(장착된) 타이어의 roll() 메소드 호출
    }
}
